.include "m328pbdef.inc"
.equ FOSC_MHZ = 16		; Microcontroller operating frequency in MHz
.equ DEL_mS = 500		; Delay in mS (valid number from 1 to 4095)
.equ DEL_NU = FOSC_MHZ * DEL_mS ; _delay_mS routine: (1000*DEL_NU+6) cycles

.def DC_VALUE = r16		; For Duty Cycle
    
.org 0x0
    rjmp reset
      
reset:
    ; Stack initialisation
    ldi r24,LOW(RAMEND)
    out SPL,r24
    ldi r24,HIGH(RAMEND)
    out SPH,r24
    clr r24

    ; Initialize PB1 (OC1A) as output
    sbi DDRB, DDB1
    
    ; Maybe the ones with zeros could be deleted ...
    
    ; Initialize Timer1 -> TCCR1A in FAST PWM, 8-bit
    ldi r24, (0 << WGM11) | (1 << WGM10) 
    out TCCR1A, r24
    
    ; The OC1A output of PWM (non-inverting) timer1 will be connected to the PB1 
    ldi r24, (1 << COM1A1) | (0 << COM1A0)
    out TTCR1A, r24
    
    ; f_PWM = 16MHz / (prescaler * 256) 
    ; 256 because we have 8-bit timer = (1 + TOP), where TOP = 255
    ; So if we choose prescaler = 1 (CS10 = 1), f_PWM = 62,5KHz
    ; Initialize Timer1 -> TCCR1B in FAST PWM, 8-bit
    ldi r24, (1 << CS10) | (1 << WGM12)
    out TCCR1B, r24
    
    ; Initialize the Duty Cycle variable to 50% 
    ldi DC_VALUE, 6		; Value 128 from the table (50%)
    rcall update_PWM
    
    ; Initialize PD3, PD4 as inputs
    ldi r24, 0x18
    out DDRD, r24
    
    ; Another way of doing the above
    ;cbi DDRD, DDD3            ; PD3 as input
    ;sbi PORTD, PD3            ; Trigger pull-up registor of PD3
    ;cbi DDRD, DDD4            ; PD4 as input
    ;sbi PORTD, PD4            ; Trigger pull-up registor of PD4
    
loop:
    in r26, PIND		; Read the state of PORTD
    mov r25, r26		; Preserve inpute value into r25
    andi r25, 0x18		; Mask for PD3, PD4
    cpi r25, 0x18		; If both PINs are pressed, do nothing
    breq loop			; Loop again
    
    sbrs r26, 3			; Skip the next instruction if PD3 is set
				; We have reverse logic in input, so if PD3 
				; is pressed, then microprocessor understands it as 0
				; and it does not skip the next operation 
    rcall increaseDC_triggered	; Jump to 'increaseDC_triggered', return with ret
    sbrs r26, 4			; Skip the next instruction if PD4 is set
    rcall decreaseDC_triggered	; Jump to 'decreaseDC_triggered', return with ret
    
    rjmp loop
    
; If PD3 is pressed   
increaseDC_triggered:
    ldi r18, 12			; Index of the maximum Duty Cycle value
    cp DC_VALUE, r18		; Compare the two indexes, and if DC_VALUE is greater
    brge end_increasing		; Don't increase (branch if greater or equal)
    inc DC_VALUE		; Increase the index, means increase another 8% the DC
    rcall update_PWM		; Go update the value from the table

    end_increasing:
	ret
    
; If PD4 is pressed  
decreaseDC_triggered: 
    ldi r18, 1			; Index of the minimum Duty Cycle value
    cp DC_VALUE, r18		; Compare the two indexes, and if DC_VALUE is less
    brle end_decreasing		; Don't decrease (branc if less or equal)
    dec DC_VALUE		; Decrease the index, means decrease another 8% the DC
    rcall update_PWM		; Go update the value from the table
    
    end_decreasing:
	ret
    
    
    
; This label loads from program memory the precomputed values for the PWM Duty Cycle.
; We use DC_VALUE as the index to select the appropriate value each time, which is 
    ; the written to the OCR1A register -> adjust the brightness of LED PB1
    ; We use Z register because we address the program memory where we
    ; have stored the table's values
update_PWM:
    ldi ZH, high(OCR_table)	; Load high byte of table address into ZH
    ldi ZL, low(OCR_table)	; Load low byte of table address into ZL
  
    add ZL, DC_VALUE		; Add the index (DC_VALUE to the low byte of Z
    ; Is it necessary to adjust the ZH ????????? I think no, because the previous calculation
    ; won't cause any carry (0-12 indexes need 4-bits, and ZL is 8-bit register)
    
    lpm r17, Z			; Loads the value from program memory (OCR_TABLE) into r17
    out OCR1A, r17		; Update the OCR1A register with the new value
    ret
    
    
; Define a table that contains precomputed values of OCR1A for various Duty Cycles
OCR_table:
    .db 5, 25, 46, 66, 86, 107, 128, 148, 168, 188, 209, 229, 250
    
; The previous values we have calculated: 
    ; For 8-bit PWM, Timer1 has a bandwith from 0 to 255 (0xFF)
    ; 2%: OCR1A = 2%*255 = 5
    ; 10%: OCR1A = 10%*255 = 25
    ; 18%: OCR1A = 46
    ; 26%: OCR1A = 66
    ; 34%: OCR1A = 86
    ; 42%: OCR1A = 107
    ; 50%: OCR1A = 128
    ; 58%: OCR1A = 148
    ; 66%: OCR1A = 168 
    ; 74%: OCR1A = 188 
    ; 82%: OCR1A = 209
    ; 90%: OCR1A = 229
    ; 98%: OCR1A = 250

; The indexing of table begins from 0